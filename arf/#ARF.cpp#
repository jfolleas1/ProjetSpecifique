/*************************************************************************
                          ARF  -  description
                             -------------------
    début                : 22/01/2016
    copyright            : (C) 2016 par jfolleas
*************************************************************************/

//------------------ class <ARF> (file Leaf.cpp) -----------------

//---------------------------------------------------------------- INCLUDE

//-------------------------------------------------------- Include système
using namespace std;
#include <iostream>
#include <sstream>
#include <fstream>
#include <vector>
#include <math.h>

//------------------------------------------------------ Include personnel
#include "ARF.h"


//---------------------------------------------------- Class variables
int ARF::minUsefullLeaf = 1;

void ARF::SetMinUsefullLeaf(int myMinUsefullLeaf)
	{
		minUsefullLeaf=myMinUsefullLeaf;
	}

//la première dimenssion correspond au bite de poid fort 
int ARF::nextNode(const vector<int> & Key , vector<int> & middle)
{
	int nextNode = 0;
	for(int i = 1; i <= dim ; i++)
	{
		if (Key[i-1]>middle[i-1])
		{
			nextNode|=(int)pow(2,dim-i);
		}
	}
	return nextNode;
}


void ARF::nextMiddleAndRangeSize(const vector<int> & Key , vector<int> & middle, int & rangeSize)
{
	
	for(int i = 0; i < dim ; i++)
	{
		if (Key[i]>middle[i])
		{
			middle[i] += rangeSize/2;
		}
		else
		{
			middle[i] -= rangeSize/2;
		}
	}
    rangeSize/=2;
}


Leaf* ARF::navigate(Node* currentNode, vector<int> & middle, int & rangeSize ,const vector<int> & Key )
{	
	//cout<<"Key : "<<Key[0]<<" "<<Key[1]<<" NSize : "<<rangeSize<<endl<<"middle : ";
	//for(int u =0; u <2 ; u++)
	//cout<<middle[u]<<"\t";
	//cout<<endl; 
	int myNextNode = this->nextNode(Key,middle);
	if(currentNode->SonIsLeaf(myNextNode))
	{
		
		return (Leaf*)currentNode->getChildNodes(myNextNode);
	}
	else
	{
		//choisir le prochain milieu et le prochain size
	//	cout<<"son is not leaf"<<endl; 
		currentNode=(Node*)currentNode->getChildNodes(myNextNode);
		this->nextMiddleAndRangeSize(Key, middle, rangeSize);
	return this->navigate(currentNode,middle,rangeSize,Key);
	}
}

void ARF::AddKey(vector<int> & Key)
{
    int rangeSize = (this->domain)/2;
    int place=-1;
    Node* currentNode = (Node*)this->root;
    Leaf* theDeepestLeaf = NULL;
    vector<int>  middle;
    for (int i =0; i<this->dim; i++)
    middle.push_back(domain/2);

 
    while(rangeSize>minRangeSize)
    {

        theDeepestLeaf=this->navigate(currentNode, middle,rangeSize,Key);//test OK
        currentNode=(Node*)theDeepestLeaf->getFather();
        
        for(int i = 0 ; i<pow(2,this->dim); i++)
        {
            if(currentNode->getChildNodes(i)==(GeneralNode*)theDeepestLeaf)
            {
                place=i;
                break;
            }
        }
        if(rangeSize>minRangeSize)
        {  //Ici viré l'ancienne leaf et ajouter les nouvelles
	myLeafs.erase((Leaf*)(currentNode->getChildNodes(place)));//ICI PB
        currentNode->Split(place);//
	for(int i =0 ; i < (int)pow(2,dim);i++)	
	myLeafs.insert((Leaf*)(((Node*)(currentNode->getChildNodes(place)))->getChildNodes(i)));
        numberOfNode++;
        numberOfLeaf+=((int)pow(2,dim)-1);        
        }
        
    }
	 
    theDeepestLeaf->SetValue(true);
}


bool ARF::CheckKey(vector<int> & Key, bool different)
{
    int rangeSize = (this->domain)/2;
    Node* currentNode = (Node*)this->root;
    Leaf* theDeepestLeaf = NULL;
    vector<int>  middle;
    for (int i =0; i<this->dim; i++)
    middle.push_back(domain/2); 
       
    theDeepestLeaf=this->navigate(currentNode, middle,rangeSize,Key);//test OK
    theDeepestLeaf->used=true;
	if(theDeepestLeaf->GetValue())
	{ cout<<"OK"<<endl;	
		if(different)
		numberOfFalsePositif++;
		//Faire l'adaptation
		else
		numberOfTruePositif++;
	return true;
	}
	else
	{
	cout<<"NOT OK"<<endl;
		numberOfTrueNegatif++;
	return false;
	}

}

// IcI a déclarer tout ce qui faut autour et à mettre dans le point h 
void ARF::DiscretiseWV(std::vector<int> Key, std::vector< std::vector<int> > & VectKeys, int numberOfElementsOnEachSide)
{
	vector < vector <int> > discretisedVector;
	vector <int> myDiscretisedElements;
	vector <int> vectorToPush;
	int myDiscretisedValue=0;
	for (std::vector< int >::iterator it = Key.begin() ; it != Key.end(); ++it)
	{
		myDiscretisedValue=(((*it)-1)/(minRangeSize))*(minRangeSize);
		myDiscretisedElements.push_back(myDiscretisedValue);
		myDiscretisedElements[0]+=(minRangeSize/2)+1;
		for(int i=1; i< numberOfElementsOnEachSide+1; i++)
		{
			myDiscretisedElements.push_back(myDiscretisedElements[0]+i*minRangeSize);
			myDiscretisedElements.push_back(myDiscretisedElements[0]-i*minRangeSize);
						
		}
		discretisedVector.push_back (myDiscretisedElements);
		myDiscretisedElements.erase(myDiscretisedElements.begin(), myDiscretisedElements.end());
	}
	this->InsertPotentialVectorWV(discretisedVector,vectorToPush, VectKeys );
}

//	ICI a modifier quand on sera plus au calme
void ARF::InsertPotentialVectorWV(const vector< vector<int> > & discretisedVector, vector<int> & vectorToPush , std::vector< std::vector<int> > & VectKeys  )
{
	if(discretisedVector.size() != vectorToPush.size())
	{
		for (int i = 0 ; i < (int)discretisedVector[0].size(); i++)
			{
		vectorToPush.push_back(discretisedVector[vectorToPush.size()][i]);
		this->InsertPotentialVectorWV(discretisedVector,vectorToPush, VectKeys );
		vectorToPush.pop_back();
		}
	}
	else
	{
		VectKeys.push_back(vectorToPush);
	}
}

void ARF::Discretise(std::vector<int> Key, std::vector< std::vector<int> > & VectKeys )
{
	
	vector < pair <int,int> > discretisedVector;
	pair <int,int> mypair;
	vector <int> vectorToPush;
	int myDiscretisedValue=0;
	
			discretisedVector.erase (discretisedVector.begin(),discretisedVector.end());
			for (std::vector< int >::iterator it = Key.begin() ; it != Key.end(); ++it)
			{
				myDiscretisedValue=((*it)/(minRangeSize))*(minRangeSize);
				mypair.first=myDiscretisedValue;
				mypair.first+=(minRangeSize/2)+1;
				if( mypair.first>(*it) )
				{
					if(mypair.first-minRangeSize>0)
					mypair.second=mypair.first-minRangeSize;
					else
					mypair.second=mypair.first;
				}
				else
				{
					if(mypair.first+minRangeSize<=domain)
					mypair.second=mypair.first+minRangeSize;
					else
					mypair.second=mypair.first;
				}
				discretisedVector.push_back (mypair);
				
			}
			vectorToPush.erase (vectorToPush.begin(),vectorToPush.end());
			this->InsertPotentialVector(discretisedVector,vectorToPush, VectKeys );
}




void ARF::InsertPotentialVector(const vector<pair<int,int> > & discretisedVector, vector<int> vectorToPush , std::vector< std::vector<int> > & VectKeys  )
{
	if(discretisedVector.size() != vectorToPush.size())
	{
		vectorToPush.push_back(discretisedVector[vectorToPush.size()].first);
		this->InsertPotentialVector(discretisedVector,vectorToPush, VectKeys );
		vectorToPush.pop_back();
		vectorToPush.push_back(discretisedVector[vectorToPush.size()].second);
		this->InsertPotentialVector(discretisedVector,vectorToPush , VectKeys);
	}
	else
	{
		VectKeys.push_back(vectorToPush);
	}
}

void ARF::CheckAroundKey(DataVector* const & myDV, vector< vector<int> > & vectKeys, vector<bool> vectorIsPresent, bool distantEnough)
{
	cout<<"boolVector: "<<endl;
	for(vector<bool>::iterator it = vectorIsPresent.begin(); it != vectorIsPresent.end(); it++)
	cout<<*it<<'\t';
	cout<<endl;
	int size;
	Node* currentNode;
	Leaf* theDeepestLeaf;
	vector<int>  middle;
	bool answerOfARF=false;

	/*vector< vector<int> > vectKeys;
	this->Discretise(Key, vectKeys);//ICI*/

//Ici faire la boucle pour toute les key discretisé
	for(vector< vector<int> >::iterator it = vectKeys.begin(); it!= vectKeys.end(); it++)
	{
		
		size = (this->domain)/2;
		currentNode = (Node*)this->root;
		theDeepestLeaf = NULL;
	   middle.clear();
	    for (int i =0; i<this->dim; i++)
	    middle.push_back(domain/2); 
	       
	    theDeepestLeaf=this->navigate(currentNode, middle,size,(*it));//test OK
	
		//cout<<"The deepest leaf is : "<<theDeepestLeaf<<endl;
	    theDeepestLeaf->used=true;

		if(vectorIsPresent[it-vectKeys.begin()])
		cout<<"n : "<<it-vectKeys.begin()<<endl;
	
		//A verifier si ispresent et get value disent bien la meme chose 	


		answerOfARF|=theDeepestLeaf->GetValue();
	/*	if(!(vectorIsPresent[it-vectKeys.begin()]) && theDeepestLeaf->GetValue() )
		{
			
			//cout<<"ARF pas assez précis \r\n";
			this->nextMiddleAndRangeSize((*it),middle,size);
			// passe defois deux fois mais probleme avec le deuxieme milieu


		/*	bool isOutTheRange = false;
			for(int j = 0 ; j < dim; j++)
			isOutTheRange |=( ((*it)[j]<(middle[j]-(size))) || ( (*it)[j]>(middle[j]+(size)) ) ); 
			

			int toto;
			if(!isOutTheRange)
			{cout<<"l'enculer repond à la condition évidente"<<endl;}*/
			/*cout<<"l'emerdeur :";
			for(int j = 0; j< dim ; j++)
			cout<<(*it)[j]<<"\t";
			cout<<endl;*/
			/*this->DoAddapt(myDV, theDeepestLeaf, middle , size);
			break;	
		}*/
	
		
	}
		if(answerOfARF)
		{	//cout<<"OK"<<endl;
			if(distantEnough)
			numberOfFalsePositif++;
			else
			numberOfTruePositif++;
		}
		else
		{	cout<<"NOT OK"<<endl;
			numberOfTrueNegatif++;
		}

}


void ARF::DoAddapt(DataVector* const & myDV, Leaf* & theDeepestLeaf , const std::vector<int> & middle ,const int & size)
{

	/*for(int i =0; i < 2; i++)
	cout<<middle[i]<<"\t";
	cout<<endl;
	cout<<"size "<<size<<endl;*/
	vector< vector<int> > potentialKeys;
	vector<int> leafTrue;
	int place = -1;	

		bool isOutTheRange = false;
		for(set< vector<int> >::const_iterator itData = myDV->Data.begin();itData != myDV->Data.end(); itData++ )
		{	
			isOutTheRange = false;
			for(int j = 0 ; j < dim; j++)
			isOutTheRange |=( ((*itData)[j]<(middle[j]-(2*size))) || ( (*itData)[j]>(middle[j]+(2*size)) ) ); 
			

			if(!isOutTheRange)
			{
			potentialKeys.push_back((*itData));
			}
		}
	
	Node* father = (Node*)theDeepestLeaf->getFather();
	//cout<<"father : "<<father<<endl;
	//cout<<"root : "<<root<<endl;
	for(int i = 0; i< (int)pow(2,dim); i++)
	{	
		if(theDeepestLeaf==(Leaf*)father->getChildNodes(i))
		place = i;
	}
	//cout<<"place : "<<place<<endl;
	myLeafs.erase((Leaf*)(father->getChildNodes(place)));
	//cout<<"=============================="<<endl;
	father->Split(place);
	//this->printARF();
	//cout<<"=============================="<<endl;
	for(int i =0 ; i < (int)pow(2,dim);i++)	
	{
	myLeafs.insert((Leaf*)(((Node*)(father->getChildNodes(place)))->getChildNodes(i)));
	((Leaf*)(((Node*)(father->getChildNodes(place)))->getChildNodes(i)))->used = true;
	}
        numberOfNode++;
        numberOfLeaf+=((int)pow(2,dim)-1);    

	for(vector< vector<int> >::iterator it = potentialKeys.begin(); it != potentialKeys.end(); it++)
	{
		 this->QuickAddKey(*it, size, middle, (Node*)(father->getChildNodes(place)) );
	}
	//this->printARF();
	//cout<<"=============================="<<endl;
	this->erase();
}


void ARF::QuickAddKey(const std::vector<int> & Key, int rangeSize, std::vector<int> middle,Node* currentNode )
{
	
	Leaf* theDeepestLeaf = NULL;
	rangeSize=domain;
	for(int i = 0 ; i<dim ; i++)
	middle[i]=domain/2;
	currentNode= (Node*)root ;
	theDeepestLeaf=this->navigate(currentNode, middle,rangeSize,Key);//test OK
    	theDeepestLeaf->SetValue(true);
}


ARF::ARF(const int & myDim, const int & myMinRangeSize,const int & myDomain, const int & myTargetSize)
	{
		targetSize=myTargetSize;
		numberOfFalsePositif=0;
		numberOfTruePositif=0;
		numberOfTrueNegatif=0;
		domain=(int)pow(2,myDomain)*myMinRangeSize;
		dim=myDim;
		Node::SetDim(dim);
		minRangeSize=myMinRangeSize;
		Node::SetMinRangeSize(minRangeSize);
		root = new Node(NULL);
		for(int i =0 ; i < (int)pow(2,dim);i++)
		myLeafs.insert((Leaf*)(((Node*)root)->getChildNodes(i)));

        numberOfNode=1;
        numberOfLeaf=(int)pow(2,dim);

	

	}

int ARF::Size()
{

	return numberOfNode*(int)pow(2,dim)+numberOfLeaf*2;
}

void ARF::resetStatistics()
{
		numberOfFalsePositif=0;
		numberOfTruePositif=0;
		numberOfTrueNegatif=0;
}


void ARF::erase()
{
	
	bool reduced = true;
	while(reduced)
	{
	reduced = false;
	 for (  std::set<Leaf*>::iterator it=myLeafs.begin(); it!=myLeafs.end(); ++it)
	    	{
			
			//if my dady only got leaf child
			if(((Node*)((*it)->getFather()))->OnlyGotLeafChild() && ((Node*)((*it)->getFather()))->LeafGotSameValue())
			{
				//cout<<"same values"<<endl;
				reduced=true;	
				Node* father=(Node*)((*it)->getFather());

				for(int i = 0 ; i < (int)pow(2,dim); i++)
				myLeafs.erase((Leaf*)(father->getChildNodes(i)));
				numberOfLeaf-=pow(2,dim);	


				
				myLeafs.insert(father->Merge());
				delete father;
				numberOfNode--;
				numberOfLeaf++;	
				break;
			}
		}
	}
	
	

	/*for (  std::set<Leaf*>::iterator it=myLeafs.begin(); it!=myLeafs.end(); ++it)
	 			cout<<(*it)<<endl;*/

	while(this->Size()> targetSize)
	{
		//cout<<"use the bit used"<<endl;	
		for (  std::set<Leaf*>::iterator it=myLeafs.begin(); it!=myLeafs.end(); ++it)
	    	{
			//if my dady only got leaf child
			if(((Node*)((*it)->getFather()))->OnlyGotLeafChild())
			{	
				if( !((Node*)((*it)->getFather()))->GotUsefulLeafs(minUsefullLeaf))
				{

				//cout<<"not useful"<<endl;	
				Node* father=(Node*)((*it)->getFather());

				for(int i = 0 ; i < (int)pow(2,dim); i++)
				myLeafs.erase((Leaf*)(father->getChildNodes(i)));
			


				
				myLeafs.insert(father->Merge());
				delete father;
				numberOfNode--;
        			numberOfLeaf-=((int)pow(2,dim)-1);	

				
				//break;
				}
				if(this->Size()< targetSize)
				break;
				//else 
				//{				
				for(int i = 0 ; i < 4*(int)pow(2,dim); i++)
it++;
				//}
			}
		}
	}
}


void ARF::DispStatistics()
{
		cout<<"FP : "<<numberOfFalsePositif<<endl;
		cout<<"TP : "<<numberOfTruePositif<<endl;
		cout<<"TN : "<<numberOfTrueNegatif<<endl;
}

ARF::~ARF()
	{
		delete root;
	}

void ARF::printARF()
	{
		cout<<"dom="<<domain<<"dim="<<dim<<" R="<<minRangeSize<<endl;
	        root->printData();
	}
    
